/** *  * RTween ColorFilter Module *  * @author Richard Rodney * @version 0.1 */package railk.as3.motion.modules{	import flash.filters.ColorMatrixFilter;	import railk.as3.motion.utils.Prop;	public class ColorFilterModule {		static private var ID:Array = [1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0];		static private var lR:Number=0.212671;		static private var lG:Number=0.715160;		static private var lB:Number = 0.072169;		static private var defaults:Object = { brightness:0, contrast:0, saturation:1, hue:0, colorize:0x000000 };				static public function update( target:Object, props:Prop, ratio:Number ):Prop {			var cmf:ColorMatrixFilter, m:Array=ID, filters:Array=target.filters, i:int=0, count:int=filters.length, p:Object=props.end;			//for ( i=0; i<count; i++ ) { if ( filters[i] is ColorMatrixFilter ) cmf = filters[i]; }						if(p.brightness) m = brightness(m, p.brightness[3]*ratio);			if(p.contrast) m = contrast(m, p.contrast[3]*ratio);			if(p.tint) m = tint(m, p.tint[3],ratio);			if(p.hue) m = hue(m, p.hue[3]*ratio);			if(p.saturation) m = saturation(m, p.saturation[3]*ratio);			if (p.threshold) m = threshold(m, p.threshold[3] * ratio);			cmf = new ColorMatrixFilter(m);			for ( i = 0; i < count; i++ ) { if ( filters[i] is ColorMatrixFilter ) filters.splice(i,1); }			filters.push( cmf );			target.filters = filters;						return props;		}				static private function tint( m:Array, c:Number, n:Number=NaN):Array {			if (isNaN(c)) return m;			else if (isNaN(n)) n = 1;			var r:Number=((c >> 16)&0xff)/255, g:Number=((c >> 8)&0xff)/255, b:Number=(c&0xff)/255, inv:Number=1-n;			var tmp:Array = [inv+n*r*lR,n*r*lG,n*r*lB,0,0,n*g*lR,inv+n*g*lG,n*g*lB,0,0,n*b*lR,n*b*lG,inv+n*b*lB,0,0,0,0,0,1,0];					return applyMatrix(tmp, m);		}				static private function brightness( m:Array,n:Number):Array {			if (isNaN(n)) return m;			n = (n * 100) - 100;			return applyMatrix([1,0,0,0,n,0,1,0,0,n,0,0,1,0,n,0,0,0,1,0,0,0,0,0,1], m);		}				static private function contrast( m:Array, n:Number):Array {			if (isNaN(n)) return m;			n += 0.01;			var tmp:Array =  [n,0,0,0,128*(1-n),0,n,0,0,128*(1-n),0,0,n,0,128*(1-n),0,0,0,1,0];			return applyMatrix(tmp,m);		}				static private function hue( m:Array , n:Number):Array {			if (isNaN(n)) return m;			n *= Math.PI / 180;			var c:Number = Math.cos(n), s:Number = Math.sin(n);			var tmp:Array = [(lR+(c*(1-lR)))+(s*(-lR)),(lG+(c*(-lG)))+(s*(-lG)),(lB+(c*(-lB)))+(s*(1-lB)),0,0,(lR+(c*(-lR)))+(s*0.143),(lG+(c*(1-lG)))+(s*0.14),(lB+(c*(-lB)))+(s*-0.283),0,0,(lR+(c*(-lR)))+(s*(-(1-lR))),(lG+(c*(-lG)))+(s*lG),(lB+(c*(1-lB)))+(s*lB),0,0,0,0,0,1,0,0,0,0,0,1];			return applyMatrix(tmp, m);		}				static private function saturation( m:Array, n:Number):Array {			if (isNaN(n)) return m;			var inv:Number=1-n, r:Number=inv*lR, g:Number=inv*lG, b:Number=inv*lB;			var tmp:Array = [r+n,g,b,0,0,r,g+n,b,0,0,r,g,b+n,0,0,0,0,0,1,0];			return applyMatrix(tmp, m);		}				static private function threshold( m:Array, n:Number):Array {			if (isNaN(n)) return m;			var tmp:Array = [lR*256,lG*256,lB*256,0,-256*n,lR*256,lG*256,lB*256,0,-256*n,lR*256,lG*256,lB*256,0,-256*n,0,0,0,1,0];			return applyMatrix(tmp, m);		}				static private function applyMatrix(m:Array, m2:Array):Array {			if (!(m is Array) || !(m2 is Array)) return m2;			var tmp:Array=[], i:int=0, z:int = 0, y:int, x:int;			for (y = 0; y < 4; y++) {				for (x = 0; x < 5; x++) {					if (x == 4) z=m[i+4];					else z=0;					tmp[i+x] = m[i]*m2[x]+m[i+1]*m2[x+5]+m[i+2]*m2[x+10]+m[i+3]*m2[x+15]+z;				}				i+=5;			}			return tmp;		}	}}