// GDS: rotationMode? X// GDS: percent progress points? X// GDS: still has problems with setting delay on an autoplaypackage railk.as3.tween.process {		import flash.display.Shape;	import flash.events.Event;	import flash.events.EventDispatcher;	import flash.events.IEventDispatcher;	import flash.utils.Dictionary;		import railk.as3.tween.process.utils.*;		public class Process extends EventDispatcher {				public static const TIME                                               :String = "time";		public static const FRAME                                              :String = "frame";		public static const HYBRID                                             :String = "hybrid";		public static const BEGINNING                                          :String = "beginning";		public static const DELAY_PHASE                                        :String = "delayPhase";		public static const TWEEN_PHASE                                        :String = "tweenPhase";		public static const END                                                :String = "end";		public static const PROGRESS                                           :String = "progress";			public static var paused                                               :Boolean = false;				protected static var activeTweens                                      :Dictionary = new Dictionary(false);		protected static var _timingMode                                       :String;		protected static var _timeInterval                                     :uint = 40;		protected static var ticker                                            :ITicker;				public var useSmartRotation                                            :Boolean = true;		public var autoPlay                                                    :Boolean = true;		public var transitionFunction                                          :Function;		public var nextTween                                                   :Process;		public var autoReverse                                                 :Boolean = false;		public var assignmentTarget                                            :Object;		public var assignmentProperty                                          :String;				protected var _target                                                  :Object;		protected var _position                                                :Number=0;		protected var _duration                                                :Number=10;		protected var _lastProgressPoint                                       :ProgressPoint;		protected var _autoHide                                                :Boolean=true;		protected var _proxy                                                   :TargetProxy;		protected var _paused                                                  :Boolean=true;		protected var _state                                                   :String = BEGINNING;		protected var _delay                                                   :Number = 0;		protected var destProperties                                           :Object;		protected var initProperties                                           :Object;		protected var invalid                                                  :Boolean=false;		protected var children                                                 :Dictionary;		protected var hasSetSize                                               :Boolean = false;		protected var hasAlphaAndVisible                                       :Boolean = true;		protected var progressPoints                                           :Array;		protected var positionOffset                                           :Number = NaN;		protected var ticker                                                   :ITicker;		protected var clearProperties                                          :Boolean = true;									// constructor:		/**		*		* @param target 			The object whose properties will be tweened. Defaults to null.		* @param duration 			The length of the tween in frames or seconds depending on the timingMode. Defaults to 10.		* @param props 				An object containing destination property values. For example, to tween to x=100, y=100, you could pass {x:100, y:100} as the props object.		* @param tweenProperties 	Indicates whether the tween should automatically play when a destination value is changed. Defaults to true.		**/		public function Process(target:Object=null, duration:Number=10, properties:Object=null, tweenProperties:Object=null) {			if (_timingMode == null) { timingMode = TIME; }			ticker = Process.ticker;			progressPoints = [];			children = new Dictionary(true);			this.target = target;			_duration = duration;			setTweenProperties(tweenProperties);			setProperties(properties);		}			// public methods:		public function invalidate():void {			invalid = true;			if (_position > 0) { positionOffset = ticker.position-(_position = 0); } // ticker.interval			if (autoPlay) { play(); }			else if (_state == END) { _state = BEGINNING; }		}				/**		*		* @param reverseChildren Indicates whether to call reverse on all child tweens.		**/		public function reverse(reverseChildren:Boolean=true):void {			var o:Object = destProperties;			destProperties = initProperties;			initProperties = o;			invalid = false;			if (_state == TWEEN_PHASE) { positionOffset = ticker.position-(_position = _duration-_position); }			if (reverseChildren) {				for (var n:Object in children) { (n as Process).reverse(); }			}			if (autoPlay) { play(); }		}				public function setTweenProperties(tweenProperties:Object):void {			if (!tweenProperties) { return; }			if ("duration" in tweenProperties) { // set duration first, because other properties (like position) may have dependencies. 				duration = tweenProperties.duration;				delete(tweenProperties.duration);			}			for (var n:String in tweenProperties) {				this[n] = tweenProperties[n];			}		}				/**		*		* @param assignmentTarget The object to reassign the property on.		* @param assignmentProperty The name of the property to reassign the target to.		**/		public function setAssignment(assignmentTarget:Object=null, assignmentProperty:String=null):void {			this.assignmentTarget = assignmentTarget;			this.assignmentProperty = assignmentProperty;		}				/**		*		* @param propertyName The name of the property to tween.		* @param value The numeric destination value (the value to tween to).		**/		public function setProperty(propertyName:String,value:Number):void {			if (isNaN(value)) { return; }			if (_state == END) { reset(); }			destProperties[propertyName] = value;			invalidate();		}				/**		*		* @param propertyName The name of the property to return a destination value for.		**/		public function getProperty(propertyName:String):Number {			return destProperties[propertyName];		}				/**		*		* @param propertyName The name of the destination property to delete.		**/		public function deleteProperty(propertyName:String):Boolean {			return delete(destProperties[propertyName]);		}				/**		*		* @param props An object containing destination property values.		**/		public function setProperties(properties:Object):void {			if (!properties) { return; }			for (var key:String in properties) {				setProperty(key,properties[key]);			}		}				/**		* Adds a child tween. Child tweens are played in synch with their parent (ie. their position properties are synchronized).		* By specifying true for synchDuration, you can also ensure that a child will keep its duration synchronized with its parent.		*		* @param child A GTween instance to add as a child tween.		* @param synchDuration indicates whether the child tween's duration property should be kept in synch with the parent. Defaults to true. You may choose to set this to false if you have a shorter tween as a child, and want it to end sooner than its parent.		**/		public function addChild(child:Process,synchDuration:Boolean=true):void {			if (!child) { return; }			children[child] = synchDuration;			child.paused = true;			if (synchDuration) { child.duration = _duration; }		}				/**		*		* @param child The child GTween instance to remove.		**/		public function removeChild(child:Process):void {			delete(children[child]);		}				/**		* Pauses the tween by stopping tick from being automatically called. This also releases the tween for garbage collection if		* it is not referenced externally.		**/		public function pause():void {			paused = true;		}				/**		* Plays a tween by incrementing the position property each frame. This also prevents the tween from being garbage collected while it is active.		* This is achieved by way of two methods:		* 1. If the target object is an IEventDispatcher, then the tween will subscribe to a dummy event using a hard reference. This allows		* the tween to be garbage collected if its target is also collected, and there are no other external references to it.		* 2. If the target object is not an IEventDispatcher, then the tween is placed in the activeTweens list, to prevent collection until it is paused or reaches the end of the transition).		* Note that pausing all tweens via the GTween.paused static property will not free the tweens for collection.		**/		public function play():void {			paused = false;		}				/**		* Jumps the tween to its beginning and pauses it. This sets all target properties to their init values, and sets the state to BEGINNING.		**/		public function beginning():void {			updateProperties(0);			positionOffset = ticker.position-(_position = -_delay);			for (var o:Object in children) { (o as Process).beginning(); }			_state = BEGINNING;			pause();		}				/**		* Jumps the tween to its end. This is the same as setting position=duration, except it also provides you with the option to also end the nextTween (recursively).		* This sets all target properties to their destination values, sets the state to END, and fires the COMPLETE event.		**/		public function end(endNextTween:Boolean=true):void {			position = _duration;			if (endNextTween && nextTween) { nextTween.end(); }		}				/**		* Resets the tween, pausing it, deleting all destination values, resetting the tween position to the beginning, and nulling the lastProgressPoint.		* This will not change the target's current properties.		**/		public function reset():void {			_position = -_delay;			_state = BEGINNING;			pause();			initProperties = _lastProgressPoint = null;			destProperties = {};		}				/**		* Adds a tween position at which to generate a progress event. You can use this to trigger other functionality at specific points in the tween.		* The name is the string value that lastProgressPoint will be set to when the event is dispatched.		* <br/><br/>		* <b>Example:</b> This will generate a progress event and set the lastProgressPoint to "middle" half way through a 5 second tween:		* <code>myGTween.addProgressPoint(2.5, "middle");</code>		*		* @param position The position at which to dispatch a progress event.		* @param data The name that will be set to lastProgressPoint when this progress point is reached.		**/		public function addProgressPoint(position:Number,data:*):void {			removeProgressPoint(data);			progressPoints.push(new ProgressPoint(position, data));			progressPoints.sortOn("position",Array.NUMERIC);		}				/**		* Removes the progress point with the specified name.		*		* @param data The data associated with the progress point to remove.		**/		public function removeProgressPoint(data:*):void {			for (var i:int=progressPoints.length-1; i>=0; i--) {				if (progressPoints[i].data == data) {					progressPoints.splice(i,1);					break;				}			}		}				// overidden for optimization purposes.		/** @private **/		override public function dispatchEvent(evt:Event):Boolean {			// this is a lot more efficient for GTweens that don't have listeners for a particular event type.			if (hasEventListener(evt.type)) { return super.dispatchEvent(evt); }			return true;		}					// private methods:				// tick event handler.		/** @private **/		protected function handleTick(evt:Event):void {			if (Process.paused) { positionOffset = ticker.position-_position; return; }			position = ticker.position - positionOffset;		}				// called when the tween ends.		/** @private **/		protected function endTransition():void {			_state = END;			paused = true;			dispatchEvent(new Event(Event.COMPLETE));			if (autoReverse) { reverse(); }			if (nextTween) { nextTween.play(); }		}				// called when the tween moves from the DELAY_PHASE state to TWEEN_PHASE		/** @private **/		protected function init():void {			_state = TWEEN_PHASE;			copyInitProperties();			dispatchEvent(new Event(Event.INIT));		}				// called when the tween first starts playing:		/** @private **/		protected function activate():void {			_state = (_position < 0) ? DELAY_PHASE : TWEEN_PHASE;			dispatchEvent(new Event(Event.ACTIVATE));			if (_position >= 0) { init(); }		}				// logic that runs each frame. Calculates position, updates properties, synchs children, handles events, etc.		/** @private **/		protected function update():void {			if (_state == BEGINNING || _state == END) { activate(); }			if (_position < 0) { return; }			// handle state:			if (_state == DELAY_PHASE) { init(); }			else if (_state == TWEEN_PHASE && invalid) { copyInitProperties(); }						if ( transitionFunction == null ) trace( 'null' );			var f:Function = (transitionFunction == null) ? linearTween : transitionFunction;						var value:Number = f(_position / _duration, 0, 1, 1);			trace( value );			updateProperties(value);			for (var o:Object in children) { (o as Process).position = _position; }			if (hasAlphaAndVisible && _autoHide) { _target.visible = (_target.alpha > 0); }						checkProgressPoint();						if (_position >= _duration) { endTransition(); }		}				// iterates all of the active properties and updates their values on the target.		/** @private **/		protected function updateProperties(value:Number):void {			var sizeSet:Boolean = false;			for (var n:String in destProperties) {				if (hasSetSize && !sizeSet && (n == "width" || n == "height")) {					sizeSet = true;					var w:Number = (destProperties["width"] == null) ? _target.width : initProperties["width"]+(destProperties["width"]-initProperties["width"])*value;					var h:Number = (destProperties["height"] == null) ? _target.height : initProperties["height"]+(destProperties["height"]-initProperties["height"])*value;					_target["setSize"](w,h);				} else {					_target[n] = initProperties[n]+(destProperties[n]-initProperties[n])*value;				}			}			if (assignmentTarget && assignmentProperty) { assignmentTarget[assignmentProperty] = _target; }		}				// determines the current progress point and fires a progress event if it has changed.		/** @private **/		protected function checkProgressPoint():void {			var obj:ProgressPoint = null;			for (var i:uint=0; i<progressPoints.length; i++) {				if (progressPoints[i].position > _position) { break; }				obj = progressPoints[i] as ProgressPoint;			}			if (obj != null && obj != _lastProgressPoint) {				_lastProgressPoint = obj;				dispatchEvent(new Event(PROGRESS));			}		}				// copies the initial target properties into the local store.		/** @private **/		protected function copyInitProperties():void {			if (!invalid) { return; }			if (assignmentTarget && assignmentProperty) { _target = assignmentTarget[assignmentProperty]; }			initProperties = {};			for (var n:String in destProperties) {				if (useSmartRotation && n == "rotation") {					var tr:Number = destProperties["rotation"] %360;					var r:Number = initProperties["rotation"] = _target[n] %360;					tr += (Math.abs(tr-r) < 180) ? 0 : (tr>r) ? -360 : 360;					destProperties[n] = tr;				} else {					initProperties[n] = _target[n];				}			}			invalid = false;		}				// default tween function.		/** @private **/		protected function linearTween(value:Number, ...args:Array):Number {			return value;		}				// this is used as a listener for GC reasons.		/** @private **/		protected function nullListener(evt:Event):void { }					// public getter/setters:			public static function get timingMode():String {			return _timingMode;		}		public static function set timingMode(value:String):void {			value = (value == FRAME || value == HYBRID) ? value : TIME;			if (value == _timingMode) { return; }			_timingMode = value;			if (_timingMode == TIME) {				ticker = new TimeTicker();				(ticker as TimeTicker).interval = _timeInterval/1000;			} else if (_timingMode == FRAME) {				ticker = new FrameTicker();			} else {				ticker = new HybridTicker();			}		}				public static function get timeInterval():uint {			return _timeInterval;		}		public static function set timeInterval(value:uint):void {			_timeInterval = value;			if (ticker is TimeTicker) { (ticker as TimeTicker).interval = _timeInterval/1000; }		}				public function get proxy():Object {			if (_proxy == null) { _proxy = new TargetProxy(this); }			return _proxy;		}				public function get position():Number {			return _position;		}		public function set position(value:Number):void {			value = (value > _duration) ? _duration : ((value < -_delay) ? -_delay : value);			if (_position == value) { return; }			positionOffset = ticker.position-(_position = value);			update();		}				public function get duration():Number {			return _duration;		}		public function set duration(value:Number):void {			_duration = value;			for (var n:Object in children) {				if (children[n]) {					(n as Process).duration = _duration;				}			}		}				public function get delay():Number {			return _delay;		}		public function set delay(value:Number):void {			if (_state == BEGINNING || _position == -_delay) {				positionOffset = ticker.position-(_position = -value);			}			_delay = value;		}				public function get target():Object {			return _target;		}		public function set target(value:Object):void {			_target = (value === null) ? {} : value;			hasSetSize = "setSize" in _target;			hasAlphaAndVisible = "alpha" in _target && "visible" in _target;			reset();		}				public function get autoHide():Boolean {			return _autoHide;		}		public function set autoHide(value:Boolean):void {			_autoHide = value;			if (hasAlphaAndVisible) {				_target.visible = (_target.alpha > 0);			}		}				public function get lastProgressPoint():* {			return (_lastProgressPoint) ? _lastProgressPoint.data : null;		}				public function get state():String {			return _state;		}				public function get paused():Boolean {			return _paused;		}		public function set paused(value:Boolean):void {			if (_paused == value) { return; }			_paused = value;			if (value) {				ticker.removeEventListener("tick",handleTick);				// free this instance for collection:				if (_target is IEventDispatcher) { _target.removeEventListener("GDS__NONEXISTENT_EVENT", nullListener); }				delete(activeTweens[this]);			} else {				if (_state == BEGINNING || _state == END) {					_position = -_delay;					activate();				}				positionOffset = ticker.position-_position;				ticker.addEventListener("tick",handleTick);				// lock the tween in memory while it's active:				if (_target is IEventDispatcher) { _target.addEventListener("GDS__NONEXISTENT_EVENT", nullListener,false,0,false); }				else { activeTweens[this] = true; }			}		}	}}