/** * CollisionDetectionクラス * 複雑な形状の衝突判定 * * @author		scratchbrain * @version		1.0.0 * @update      2008/07/08 * @web site    http://www.scratchbrain.net/ * @blog        http://www.scratchbrain.net/blog/ver2/ * */package railk.as3.geom{	import flash.display.BitmapData;	import flash.display.BlendMode;	import flash.display.DisplayObject;	import flash.display.DisplayObjectContainer;	import flash.geom.Matrix;	import flash.geom.ColorTransform;	import flash.geom.Rectangle;		public class CollisionDetection	{		public static function checkForCollision(obj1:DisplayObject,obj2:DisplayObject):Rectangle {			var bounds1:Object = obj1.getBounds(obj1.root);			var bounds2:Object = obj2.getBounds(obj2.root);						if (((bounds1.right < bounds2.left) || (bounds2.right < bounds1.left)) || ((bounds1.bottom < bounds2.top) || (bounds2.bottom < bounds1.top)) ) return null;						var bounds:Object = {};			bounds.left = Math.max(bounds1.left,bounds2.left);			bounds.right= Math.min(bounds1.right,bounds2.right);			bounds.top = Math.max(bounds1.top,bounds2.top);			bounds.bottom = Math.min(bounds1.bottom,bounds2.bottom);						var w:Number = bounds.right-bounds.left;			var h:Number = bounds.bottom-bounds.top;			if(w < 1 || h < 1) return null;			var bitmapData:BitmapData = new BitmapData(w,h,false);						var matrix:Matrix = obj1.transform.concatenatedMatrix;			matrix.tx -= bounds.left;			matrix.ty -= bounds.top;			bitmapData.draw(obj1,matrix,new ColorTransform(1,1,1,1,255,-255,-255,255));						matrix = obj2.transform.concatenatedMatrix;			matrix.tx -= bounds.left;			matrix.ty -= bounds.top;			bitmapData.draw(obj2,matrix,new ColorTransform(1,1,1,1,255,255,255,255),BlendMode.DIFFERENCE);					var intersection:Rectangle = bitmapData.getColorBoundsRect(0xFFFFFFFF,0xFF00FFFF);						if (!intersection.width) return null;					intersection.x += bounds.left;			intersection.y += bounds.top;						return intersection;		}	}}