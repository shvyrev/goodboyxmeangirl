/** *  * RTween Filter Module *  * @author Richard Rodney * @version 0.1 */package railk.as3.motion.modules{	import flash.filters.ColorMatrixFilter;	import flash.filters.BitmapFilter;	public class FilterModule 	{		static private var id:Array=[1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0];		static private var lR:Number=0.212671;		static private var lG:Number=0.715160;		static private var lB:Number=0.072169;		static private var filter:BitmapFilter;		static private var filterList:Array;		static private var blur:Array=["blurX","blurY","quality"];		static private var glow:Array=["alpha","blurX","blurY","color","quality","strength","inner","knockout"];		static private var dropShadow:Array=["alpha","angle","blurX","blurY","color","distance","quality","strength","inner","knockout","hideObject"];		static private var bevel:Array=["angle","blurX","blurY","distance","highlightAlpha","highlightColor","quality","shadowAlpha","shadowColor","strength"];				static public function update( target:Object, props:Array, ratio:Number ):Array		{			//current = ColorMatrixFilter(filter).matrix;			//for(propName in propNames) _from[propName] = _current[propName];						/*for(propName in propNames) {				current[propName] = from[propName] * q + to[propName] * position;				current[propName] = (current[propName]);			}						var f:Array = _target.filters;			for (i = 0; i < _filters.length; i++) {				for (j = f.length - 1; j > -1; j--) {					if (f[j] is _filters[i].type) {						f.splice(j, 1, _filters[i].filter);						break;					}				}			}*/			//if( filter is ColorMatrixFilter) ColorMatrixFilter(filter).matrix = current as Array;			//displayObject.filters = filterList;			return props;		}				public function brightness( m:Array,n:Number):Array {			if (isNaN(n)) return m;			n = (n * 100) - 100;			return applyMatrix([1,0,0,0,n,0,1,0,0,n,0,0,1,0,n,0,0,0,1,0,0,0,0,0,1], m);		}				private function colorize( m:Array, c:Number, n:Number=NaN):Array {			if (isNaN(c)) return m;			else if (isNaN(n)) n = 1;			var r:Number=((c >> 16)&0xff)/255, g:Number=((c >> 8)&0xff)/255, b:Number=(c&0xff)/255, inv:Number=1-n;			var tmp:Array = [inv+n*r*lR,n*r*lG,n*r*lB,0,0,n*g*lR,inv+n*g*lG,n*g*lB,0,0,n*b*lR,n*b*lG,inv+n*b*lB,0,0,0,0,0,1,0];					return applyMatrix(tmp, m);		}				private function contrast( m:Array, n:Number):Array {			if (isNaN(n)) return m;			n += 0.01;			var tmp:Array =  [n,0,0,0,128*(1-n),0,n,0,0,128*(1-n),0,0,n,0,128*(1-n),0,0,0,1,0];			return applyMatrix(tmp,m);		}				private function hue( m:Array , n:Number):Array {			if (isNaN(n)) return m;			n *= Math.PI / 180;			var c:Number = Math.cos(n), s:Number = Math.sin(n);			var tmp:Array = [(lR+(c*(1-lR)))+(s*(-lR)),(lG+(c*(-lG)))+(s*(-lG)),(lB+(c*(-lB)))+(s*(1-lB)),0,0,(lR+(c*(-lR)))+(s*0.143),(lG+(c*(1-lG)))+(s*0.14),(lB+(c*(-lB)))+(s*-0.283),0,0,(lR+(c*(-lR)))+(s*(-(1-lR))),(lG+(c*(-lG)))+(s*lG),(lB+(c*(1-lB)))+(s*lB),0,0,0,0,0,1,0,0,0,0,0,1];			return applyMatrix(tmp, m);		}				private function saturation( m:Array, n:Number):Array {			if (isNaN(n)) return m;			var inv:Number=1-n, r:Number=inv*lR, g:Number=inv*lG, b:Number=inv*lB;			var tmp:Array = [r+n,g,b,0,0,r,g+n,b,0,0,r,g,b+n,0,0,0,0,0,1,0];			return applyMatrix(tmp, m);		}				private function threshold( m:Array, n:Number):Array {			if (isNaN(n)) return m;			var tmp:Array = [lR*256,lG*256,lB*256,0,-256*n,lR*256,lG*256,lB*256,0,-256*n,lR*256,lG*256,lB*256,0,-256*n,0,0,0,1,0];			return applyMatrix(tmp, m);		}				private function applyMatrix(m:Array, m2:Array):Array {			if (!(m is Array) || !(m2 is Array)) return m2;			var tmp:Array=[], i:int=0, z:int = 0, y:int, x:int;			for (y = 0; y < 4; y++) {				for (x = 0; x < 5; x++) {					if (x == 4) z=m[i+4];					else z=0;					tmp[i+x] = m[i]*m2[x]+m[i+1]*m2[x+5]+m[i+2]*m2[x+10]+m[i+3]*m2[x+15]+z;				}				i+=5;			}			return tmp;		}	}}